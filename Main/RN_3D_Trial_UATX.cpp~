#include </home/smm5969/Desktop/cpp/Functions/AllFunctions_JS.cpp>
//#include <C:\Users\smm5969\Box Sync\Fibrin CPP\John Snow\Functions\AllFunctions.cpp>
#include <iostream>
#include <cmath>
#include</home/smm5969/Desktop/cpp/Eigen/Eigen/Dense>
//#include<Eigen/Dense>
#include</home/smm5969/Desktop/cpp/Eigen/Eigen/Sparse>
//#include<Eigen/Sparse>
#include <tuple>
#include <math.h>
#include <fstream>
#include <time.h>
#include <omp.h>
// EIGENVALUE CALCULATION.
//#include <Eigen/Eigenvalues> 

// SOLVER
// Direct 
//#include <Eigen/SparseCholesky> 
//#include <Eigen/SparseLU> 
#include </home/smm5969/Desktop/cpp/Eigen/Eigen/SparseQR> 
//#include <Eigen/OrderingMethods>
// Iterative
//#include <Eigen/IterativeLinearSolvers>



using namespace std;
using namespace Eigen;
typedef Matrix <int, Dynamic, Dynamic> MatrixXi; // define matrix for integers.
typedef Matrix <int, 1, Dynamic> RowVectorXi; // define row vector for integers.

int main ()
{   
     
	int num_threads;
	cout << "Please enter num of threads requested: " << endl;
	cin >> num_threads;
	cout << endl;
	// String
	string filepath = "//home//smm5969//Desktop//cpp//Input//Trial_3D.txt";
        //string filepath = "C:\\Users\\smm5969\\Box Sync\\Fibrin CPP\\John Snow\\Input\\Trial_3D.txt"; 
	
	// Scalars
	
	// Vectors
	RowVectorXd Wts; // Weights of the network.
	
	// Matrices
	MatrixXd Cpt,A0,A0_Bs,P,Q; // Cpts and Triads of the network.
	Matrix3d a0; // matrix containing triad of a patch.
	
	// vector of Structures
	vector<Patch_Structure> Patch, Patch_Bs; // Patch and Patch_Bs structures of the network.
	
	
	//// Read Network geometry from the text file. (Generated by matlab) ////
	Read_IGAMeshData(filepath,Cpt,Wts,Patch,Patch_Bs,A0,A0_Bs);
        cout << "Reading IGA Mesh Data done!" << endl;  
  	
	//// Material Properties ////
	double r,Area,E,E_Bs,G,G_Arcs,v,I2,I3,Ip;
	r=0.001;Area=M_PI*pow(r,2);E=pow(10,6);v=0.2;G=0.5*(1+v)*E;I2=(M_PI/4)*pow(r,4);I3=I2;Ip=I3+I2;
	E_Bs = E*pow(10,3);G_Arcs = G*pow(10,3);
	RowVectorXd Mat(6),Mat_Arcs(6),Mat_Bs(6);
	Mat(0)=Area;Mat(1)=E;Mat(2)=G;Mat(3)=I2;Mat(4)=I3;Mat(5)=Ip;
	Mat_Bs(0)=Area;Mat_Bs(1)=E_Bs;Mat_Bs(2)=G;Mat_Bs(3)=I2;Mat_Bs(4)=I3;Mat_Bs(5)=Ip;
	Mat_Arcs(0)=Area;Mat_Arcs(1)=E_Bs;Mat_Arcs(2)=G_Arcs;Mat_Arcs(3)=I2;Mat_Arcs(4)=I3;Mat_Arcs(5)=Ip;
	
		
    //// Dof's for fibers and arcs and bending strips ////
	MatrixXi DOF,DOF_Bs;
	int num_cpt;
	num_cpt= Cpt.cols();
	DOF.resize(num_cpt,4);DOF_Bs.resize(num_cpt,4);DOF_Bs=MatrixXi::Zero(num_cpt,4);
	for (int i=0;i<num_cpt;i++)
	{
		DOF(i,0)=4*i+1;DOF(i,1)=4*i+2;DOF(i,2)=4*i+3;DOF(i,3)=4*i+4;
	}
	
	for (int i=0;i<Patch_Bs.size();i++)
	{
		for (int j=0;j<Patch_Bs[i].num_cpt;j++)
		{
			DOF_Bs.row(Patch_Bs[i].patch2cpt(j)-1)=DOF.row(Patch_Bs[i].patch2cpt(j)-1);
		}
	}
	
	//***** Boundary Conditions *****//
    //Uniaxial Tension in X
	double Max_Strain = 1;
	MatrixXd Face_D(6,4),Face_F(6,4); // 6 faces and 4 dofs 
	double u0=pow(10,10);
	Face_D << Max_Strain,u0,u0,u0,0,0,0,u0,u0,u0,u0,u0,0,0,0,u0,u0,u0,u0,u0,0,0,0,u0;
	Face_F << 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;
	MatrixXd D_DOF(num_cpt,4),F_DOF(num_cpt,4);
	
	P.resize(Cpt.rows(),Cpt.cols());
	P=Cpt;Q=P;
    SpMat K(4*P.cols(),4*P.cols());MatrixXd R(4*P.cols(),1);
	MatrixXd Dense_K;
	
		
	//**************** Analysis ****************//
    cout << "***************** Starting Analysis ******************" << endl;
    int num_inc,max_numiter;
    P=Cpt;Q=P;num_inc=1000;max_numiter=200;
	
	//// Newton Iteration ////
    double disp_ratio,disp_inc,tol_D,tol_R;
    int max_attempts;

    disp_ratio=0.0;disp_inc=1.0/float(num_inc);max_attempts=10;
    tol_D=pow(10,-6);tol_R=pow(10,-6);
    

    int ngp,order,num_iter,attempts,Stop_Key;
    

	int num_disp,num_rot;
	num_disp = 3*P.cols();num_rot = P.cols();


    MatrixXd d_DOF(D_DOF.rows(),D_DOF.cols()),R0_disp(num_disp,1),R0_rot(num_rot,1),Norm_R0(2,1),d(R.rows(),1);
    MatrixXd Q0(Q.rows(),Q.cols());
     
	
	clock_t t_iter,t_inc;
	double time_inc,time_iter,time_total=0.0;
	int inc_num = 1;
	while(disp_ratio < 1.0)
    {
	disp_ratio+=disp_inc;
    	cout << "Fraction of total strain: " << disp_ratio << endl << endl;
    	ngp=order+1;
    	tie(d_DOF,F_DOF) = RN_3D_BC( num_cpt,Cpt,Face_D,Face_F,u0,disp_ratio ); // applied boundary conditions on a unit cube.
	num_iter=1;attempts=0;Stop_Key=0;
	time_inc=omp_get_wtime();
        while(Stop_Key==0)
        {
        	cout << "Iteration No: " << num_iter << endl << endl;
                time_iter=omp_get_wtime();
			tie(K,R,Q)=Network_KR_Parallel(P,Q,Patch,Patch_Bs,A0,A0_Bs,Mat,Mat_Arcs,Mat_Bs,DOF,d_DOF,F_DOF,u0,num_threads);
			if(num_iter==1)
        	{
        		Q0=Q;

        		for (int j=0;j<Q.cols();j++)
	            {   
		        	R0_disp(3*j,0)=R(DOF(j,0)-1,0);R0_disp(3*j+1,0)=R(DOF(j,1)-1,0);R0_disp(3*j+2,0)=R(DOF(j,2)-1,0);  
                    R0_rot(j,0)=R(DOF(j,3)-1,0); 
			    }

			    R0_disp=R0_disp/(Area*E_Bs);R0_rot=R0_rot/(Ip*E_Bs/r);
                Norm_R0(0,0)=R0_disp.norm();
                Norm_R0(1,0)=R0_rot.norm();
			}

			// Calculate change in position
			// Direct Solvers
			
			SparseQR <SparseMatrix<double>,NaturalOrdering<int>> solver;
            solver.compute(K);
			if(solver.info()!=Success) 
			{
               cout << "decomposition failed" << endl << endl;
               break;
            }
			d =  -solver.solve(R);
			if(solver.info()!=Success) 
			{
                cout << "solving failed" << endl << endl;
                break;
            }
            cout << " d.norm(): " << d.norm() << endl << endl ;
            
			
			//// Stopping Criterion
            if(num_iter>1)
            {
            	int choice=2; // Displacemnt criterion only
            	Stop_Key = Stop_Criterion_Network_3D(P,Q0,Q,R,Norm_R0,d,DOF,tol_D,tol_R,choice);
			}
		    // Find new control points
		    for (int j=0; j<Q.cols();j++)
		    {   
		    	Q(0,j)+=d(DOF(j,0)-1);
				Q(1,j)+=d(DOF(j,1)-1);
				Q(2,j)+=d(DOF(j,2)-1);
				Q(3,j)+=d(DOF(j,3)-1);
                    }
	   
             time_iter = omp_get_wtime() - time_iter; 
             printf ("Time required for this iteration %f secs\n",time_iter);
             num_iter+=1;	
          }
		////// APPEND Q TO TEXT FILE //////
		string filepath2 = "//home//smm5969//Desktop//cpp//Results//Trial_3D_Results.txt";
		//string filepath2 = "C:\\Users\\smm5969\\Box Sync\\Fibrin CPP\\John Snow\\Results\\Trial_3D_Results.txt";
		ofstream result_file;
		result_file.open(filepath2,std::ios_base::app);
		result_file << Q << endl << endl << endl;
		result_file.close();
		inc_num+=1;
		
	time_inc = omp_get_wtime() - time_inc ;time_total += time_inc;
        printf ("Load Increment %d : %f seconds \n",inc_num,time_inc);
	}
	printf ("\n Total time for %d increments is %f seconds . \n",inc_num,time_total);
	return 0;
}


























